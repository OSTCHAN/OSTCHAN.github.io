---
layout: post
title: "使用C++的构造函数初始化列表的好处"
subtitle: "Benefit of using constructor initialization list"
author: "Kafka"
date: 2023-06-19
header-style: text
# multilingual: true
mathjax: true
tags:
	- Notes
	- C++
---

构造函数初始化列表的语法是在构造函数的参数列表后使用冒号（:）开头，然后在函数左大括号"{"以左，使用逗号分隔的初始化器列表来初始化类的成员变量。

```cpp
//	 Definition for singly-linked list.
struct ListNode {
	int val;
	ListNode *next;
	ListNode() : val(0), next(nullptr) {}
	ListNode(int x) : val(x), next(nullptr) {}
	ListNode(int x, ListNode next) : val(x), next(next) {}
};
```

在C++中，结构体(struct)和类(class)都可以拥有构造函数(constructor)，用于在创建对象时初始化对象的成员变量。在这个例子中，ListNode结构体拥有三个构造函数：

`ListNode() : val(0), next(nullptr) {}`
这是默认构造函数，用于创建一个值为0，指针为空的ListNode对象。

`ListNode(int x) : val(x), next(nullptr) {}`
这是带有一个整型参数的构造函数，用于创建一个值为x，指针为空的ListNode对象。

`ListNode(int x, ListNode* next) : val(x), next(next) {}`
这是带有两个参数的构造函数，用于创建一个值为x，指针指向next的ListNode对象。

重点是：
---
使用constructor initialization list语法初始化成员变量具有潜在的效率优势。它可以避免由于成员变量的默认初始化导致后续可能的重复赋值操作的开销。

在C++中，如果一个成员变量没有被初始化，它会被默认初始化。对于基本数据类型，如int、float等，它们的默认值是未定义的（实际上cpp所谓的“默认初始化”并没有“初始化”基本数据类型，换句话说就是*不管它*，变量的对应那块内存上的值原来是多少就还是多少），而对于类类型，它们的默认构造函数会被调用进行初始化。如果我们在构造函数（体）中使用赋值语句来初始化成员变量，那么它们会先被默认初始化，然后再被赋值。这样就会造成额外的开销，降低程序的效率。

E.g.:
```cpp
/* 1 */
struct ListNode {
	int val;
	ListNode *next;
	class A a;

	ListNode() : val(0), next(nullptr), a(/*parameter list*/) {} // 这里是（constructor init list的）【初始化】
};
```
和
```cpp
/* 2 */
struct ListNode {
	int val;
	ListNode *next;
	class A a;
	
	ListNode() {
		val = 0;
		next = nullptr;
		a = A(/*parameter list*/); // 这里是赋值，而不是【初始化】。
	}
};
```
C++在对象的实例化过程中使用拷贝构造函数进行操作，而不是返回指针或引用。
对于上述代码段，snippet1中使用了constructor initialization list，在未来实例化ListNode时**将不会**进行默认初始化（注意！“默认初始化”并不初始化内置类型[^1]，内置类型的初始值未定义；而类/结构体类型调用它们自己的默认构造函数进行所谓的“默认初始化”），而是采用init list设定好的初始化。

-*初始化次数：1次*

snippet2则是在默认构造函数体中进行【赋值】，而不是初始化。举个例子，在snippet2的情况下，我们实例化一个ListNode时是这样的：`ListNode node = ListNode();`。如果我之前学习到的信息无误的话，c++在调用构造函数`ListNode()`但还没进入`ListNode()`的函数体前，i.e.`ListNode() /* HERE! */ {`，或者[^2]是还没真正“调用”`ListNode()`前，会执行默认初始化，然后才执行函数体。于是，snippet2的函数体将【再】执行一次“初始化”（当然，刚刚说了实际上是赋值）。

-*初始化次数：2次*

使用constructor initialization list语法可以避免这种情况的发生。在使用constructor initialization list语法时，成员变量会直接被初始化，而不需要进行默认初始化和赋值操作。这样就可以提高程序的效率。

另外，对于const变量而言，要么在成员变量定义处就初始化了，不然就需要用init list来初始化。

题外话
---
提问：是否可以在一个类/结构体中定义一个该类/结构体类型的成员变量？
```cpp
struct ListNode {
	int val;
	ListNode node;
}
```
(灵感源自于blog一开始的ListNode函数体中的`ListNode *next;`。我一开始写错了，漏写了`*`，然后变成了`ListNode next;`...)

My fine tuned GPT answer：

不可以在一个类/结构体中定义一个该类/结构体类型的成员变量，因为这会导致无限递归的定义，使得该类/结构体的大小无限增长，编译器无法分配足够的内存。在创建类/结构体对象时，类/结构体类型的成员变量也需要被创建，而类/结构体类型的成员变量中又包含了类/结构体本身，这样就会导致无限递归。

在你提供的代码中，ListNode 类型中的 node 成员变量是 ListNode 类型的，这会导致无限递归的定义，因为 ListNode 类型的大小取决于其成员变量的大小，而其中一个成员变量又是 ListNode 类型的，这样就无限递归下去了。

只能通过在ListNode 类型中包含一个指向 ListNode 类型的指针间接的达到这个“类中类”的效果，可以这样写：

```cpp
struct ListNode {
	int val;
	ListNode* node;
};
```

这样就避免了无限递归的定义，同时也保证了 ListNode 类型的大小是固定的。

---
gpt的回答：
a = A(); 中的赋值操作符执行的是值传递，而不是引用传递或指针传递。

当执行 A() 时，会创建一个临时的 A 类对象。然后，通过赋值操作符将临时对象的值复制给变量 a。

在 C++ 中，赋值操作符 = 的默认行为是执行对象的值复制，即将一个对象的值复制到另一个对象。这是通过调用对象的拷贝构造函数或赋值操作符重载函数来实现的。

所以，a = A(); 中的赋值操作符会复制临时对象的值给变量 a，并不是传递指针或引用。

如果您想实现引用传递或指针传递，需要使用引用或指针类型的变量来接收临时对象的值。例如，A& a = A(); 或 A* a = new A();，但这需要注意临时对象的生命周期管理，确保不会出现悬空指针或访问已销毁的对象的问题。

需要注意的是，在 a = A(); 完成后，临时对象将被销毁，而变量 a 将持有临时对象的值。
```cpp
class A {
};

struct ListNode {
	int val;
	ListNode *next;
	class A a, *ptr;
	
	ListNode() {
		val = 0;
		next = nullptr;
		ptr = &a;
		a = A(/*parameter list*/); // 这里是赋值，而不是【初始化】。
	}
};

int main() {
	auto node = ListNode();
	cout << "prev: ";
	cout << node.ptr << endl;
	cout << "now: ";
	cout << &(node.a) << endl;
	return 0;
}
```
以上代码（在我的机器上）的输出结果是：
> prev: 0x61fe10
> now: 0x61fe10

![error](/img/posts-img/cpp-constructor-error.png)

一方面印证了我前面的猜测"c++在调用构造函数`ListNode()`但还没进入`ListNode()`的函数体前，i.e.`ListNode() /* HERE! */ {`，或者[^2]是还没真正“调用”`ListNode()`前，会执行默认初始化，然后才执行函数体"，另一方面也说明GPT说的没错，c++的普通默认构造函数赋值一般是拷贝，而不是返回构造的对象的引用或指针，而且默认构造函数确实是返回了一个临时对象（如图报错temporary）。

所以，`a = A(/*parameter list*/);`在这种情况下确实是重复操作了。

[^1]:因此对于内置类型来说snippet1&2两者其实没差，但是为了内置类和自定义类的统一还是选init list吧

[^2]:（宏观上看是这样的，但是具体底层细节是哪样我并不知道，对这个细节的兴趣也没多到足以让我愿意花时间去进一步查证，所以我屏蔽这个底层实现。计算机科学的最重要的一个核心方法论不就是屏蔽/抽象底层细节吗？）
